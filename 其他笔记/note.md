# 未归档笔记

- [未归档笔记](#未归档笔记)
  - [argc、argv的具体含义](#argcargv的具体含义)
  - [前缀表达式与后缀表达式问题](#前缀表达式与后缀表达式问题)
  - [c++模板类的声明与实现的分离编译问题](#c模板类的声明与实现的分离编译问题)

## argc、argv的具体含义 
> argc和argv参数在用命令行编译程序时有用。main( int argc, char* argv[], char **env ) 中 
> 
- 第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，在VS中默认值为1。 
- 第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下： 
> argv[0]指向程序运行的全路径名 
argv[1]指向在DOS命令行中执行程序名后的第一个字符串 
argv[2]指向执行程序名后的第二个字符串 
argv[3]指向执行程序名后的第三个字符串 
argv[argc]为NULL 

- 第三个参数，char**型的env，为字符串数组。env[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value为其对应的值。平时使用到的比较少。

##  前缀表达式与后缀表达式问题

![](images/前缀表达式与后缀表达式问题.png)
![](images/前缀表达式与后缀表达式转换.png)

[基于栈实现简单表达式的计算](https://www.cnblogs.com/tech-bird/p/3971555.html)


## c++模板类的声明与实现的分离编译问题

> 模板不支持分离编译, 把你模板类的声明和实现放到.h文件里面
C++中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道，模板类中使用模板类型的对象的所占用的空间的大小的。
只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。
在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。
这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。
然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。

[https://blog.csdn.net/weixin_40539125/article/details/83375452](https://blog.csdn.net/weixin_40539125/article/details/83375452)

[https://www.cnblogs.com/qlwy/archive/2012/03/21/2410045.html](https://www.cnblogs.com/qlwy/archive/2012/03/21/2410045.html)